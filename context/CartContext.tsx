
import React, { createContext, useContext, useState, useMemo } from 'react';
import { ShoppingListItem, OrchestrationPlan, Ingredient, Recipe } from '../types';
import { useLocalStorage } from '../hooks/useLocalStorage';
import * as gemini from '../services/geminiService';
import { useAuthContext } from './AuthContext';
import { consolidateShoppingList } from '../utils/shopping';

/**
 * @interface CartContextType
 * @description Defines the shape of the Cart Context, which manages the shopping cart, ingredient consolidation, and AI orchestration.
 */
export interface CartContextType {
  /** List of recipes and their scaling factors currently in the cart. */
  cart: ShoppingListItem[];
  /** Adds a recipe to the cart with a specific scaling factor. */
  addToCart: (recipe: Recipe, factor: number) => void;
  /** Removes a recipe from the cart by its unique cart item ID. */
  removeFromCart: (id: string) => void;
  /** Updates the scaling factor for a specific cart item. */
  updateCartItemFactor: (id: string, f: number) => void;
  /** Clears all items from the cart and resets the orchestration plan. */
  clearCart: () => void;
  
  // Checklist State
  /** Set of keys (name|unit) for ingredients that have been checked off. */
  checkedIngredients: Set<string>;
  /** Toggles the checked status of an ingredient. */
  toggleIngredientCheck: (key: string) => void;
  /** The consolidated list of all ingredients needed for all recipes in the cart. */
  consolidatedList: Ingredient[];
  /** Number of ingredients yet to be purchased. */
  toBuyCount: number;
  /** Number of ingredients already checked off. */
  doneCount: number;

  // Orchestration
  /** The currently active AI-generated cooking orchestration plan. */
  orchestrationPlan: OrchestrationPlan | null;
  /** Function to manually set or clear the orchestration plan. */
  setOrchestrationPlan: (plan: OrchestrationPlan | null) => void;
  /** Indicates if an orchestration plan is being generated by AI. */
  orchestrationLoading: boolean;
  /** Triggers the AI to generate a new orchestration plan based on the cart's content. */
  generateOrchestrationAction: () => Promise<void>;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

/**
 * @component CartProvider
 * @description Manages the shopping cart and cooking orchestration state.
 * It uses local storage to persist the cart and checked items across sessions.
 * It also coordinates with Gemini AI to generate orchestration plans for multiple recipes.
 */
export const CartProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isAIEnabled } = useAuthContext();
  const [cart, setCart] = useLocalStorage<ShoppingListItem[]>('chefai_cart', []);
  const [checked, setChecked] = useLocalStorage<string[]>('chefai_checked', []);
  const [orchestrationPlan, setOrchestrationPlan] = useState<OrchestrationPlan | null>(null);
  const [orchestrationLoading, setOrchestrationLoading] = useState(false);

  // --- ACTIONS ---
  const addToCart = (recipe: Recipe, factor: number) => {
    setCart(prev => [...prev, {
      id: Math.random().toString(36).substring(2, 9),
      recipeId: recipe.id,
      title: recipe.title,
      ingredients: recipe.ingredients,
      scalingFactor: factor,
      originalRecipe: recipe
    }]);
  };

  const removeFromCart = (id: string) => setCart(p => p.filter(i => i.id !== id));
  
  const updateCartItemFactor = (id: string, f: number) => {
    if (f <= 0) return;
    setCart(p => p.map(i => i.id === id ? { ...i, scalingFactor: f } : i));
  };

  const clearCart = () => {
    setCart([]);
    setOrchestrationPlan(null);
  };

  const toggleIngredientCheck = (key: string) => {
    setChecked(prev => {
      const s = new Set(prev);
      if (s.has(key)) s.delete(key); else s.add(key);
      return Array.from(s);
    });
  };

  const consolidatedList = useMemo(() => {
    return consolidateShoppingList(cart);
  }, [cart]);

  const stats = useMemo(() => {
    const s = new Set(checked);
    let done = 0;
    consolidatedList.forEach(i => { 
        const key = `${i.name.toLowerCase()}|${i.unit.toLowerCase()}`;
        if (s.has(key)) done++; 
    });
    return { doneCount: done, toBuyCount: consolidatedList.length - done };
  }, [consolidatedList, checked]);

  const generateOrchestrationAction = async () => {
    const recipes = cart.map(i => i.originalRecipe).filter(Boolean) as Recipe[];
    if (recipes.length === 0 || !isAIEnabled) return;
    setOrchestrationLoading(true);
    try {
      const plan = await gemini.generateOrchestrationPlan(recipes);
      setOrchestrationPlan(plan);
    } catch (e: any) { console.error(e); } finally { setOrchestrationLoading(false); }
  };

  return (
    <CartContext.Provider value={{
      cart, addToCart, removeFromCart, updateCartItemFactor, clearCart,
      checkedIngredients: new Set(checked), toggleIngredientCheck,
      consolidatedList, toBuyCount: stats.toBuyCount, doneCount: stats.doneCount,
      orchestrationPlan, setOrchestrationPlan, orchestrationLoading, generateOrchestrationAction
    }}>
      {children}
    </CartContext.Provider>
  );
};

/**
 * Hook to consume the CartContext.
 * @returns {CartContextType} The cart context value.
 * @throws {Error} If used outside of a CartProvider.
 */
export const useCartContext = () => {
  const context = useContext(CartContext);
  if (!context) throw new Error('useCartContext must be used within CartProvider');
  return context;
};
